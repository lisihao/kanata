# Kanata PRD 补充：战略深度与核心特色

**版本**: v1.0
**日期**: 2026-01-31
**定位**: 对 PRD v1.1 的战略级补充，回答"为什么是 Kanata"而非"Kanata 有什么功能"

---

## 一、战略诊断：当前 PRD 的核心问题

当前 PRD 本质上是一份**功能清单**，有三个致命缺陷：

1. **没有护城河**："对标并超越 Claude Code"不是战略，因为 Anthropic 随时可以发布同样功能
2. **没有杀手特性**：9 大模块都是"比别人做得全"，但没有一个让用户"非你不可"的理由
3. **没有增长飞轮**：用户越多、产品越好的正向循环没有被设计进去

以下补充旨在解决这三个问题。

---

## 二、核心特色定义：三大不可复制壁垒

### 壁垒一：Context Engine — "最懂你项目的 AI"

> **核心洞察**: 所有 Code Agent 的真正瓶颈不是模型能力，而是**上下文质量**。同一个 Claude Opus，喂入精准上下文 vs 随机上下文，输出质量天差地别。Context Engine 就是 Kanata 的"搜索引擎"——谁的上下文最精准，谁就赢。

**为什么这是护城河**: Claude Code 靠 Glob/Grep 做文件发现，本质上是**文本匹配**。Kanata 的 Context Engine 做的是**语义理解**——它知道"改了这个函数会影响哪些调用方"、"这个 Bug 的根因在三层调用之外"。这种理解需要持续积累，后来者无法速成。

```
┌────────────────────────────────────────────────────────────┐
│                    Context Engine                          │
│         "Kanata 的核心竞争力，不可替代的大脑皮层"             │
│                                                            │
│  ┌─────────────┐  ┌──────────────┐  ┌─────────────────┐  │
│  │ Code Graph  │  │ Intent Graph │  │ Project Memory  │  │
│  │ 代码语义图   │  │ 意图理解图    │  │ 项目长期记忆     │  │
│  │             │  │              │  │                 │  │
│  │ - 调用关系   │  │ - 用户真实意图│  │ - 架构决策历史   │  │
│  │ - 类型流     │  │ - 模糊指令消歧│  │ - Bug 修复模式  │  │
│  │ - 数据流     │  │ - 上下文补全  │  │ - 团队偏好      │  │
│  │ - 影响范围   │  │ - 多轮对话推理│  │ - 代码风格      │  │
│  └──────┬──────┘  └──────┬───────┘  └────────┬────────┘  │
│         │                │                    │            │
│         └────────────────┼────────────────────┘            │
│                          ↓                                 │
│              ┌───────────────────────┐                     │
│              │   Context Assembler   │                     │
│              │   上下文装配器         │                     │
│              │                       │                     │
│              │ 为每次 LLM 调用组装    │                     │
│              │ 最优上下文窗口         │                     │
│              │                       │                     │
│              │ 输入: 用户意图 + 任务  │                     │
│              │ 输出: 精确排序的上下文  │                     │
│              └───────────────────────┘                     │
└────────────────────────────────────────────────────────────┘
```

**Context Engine 三层架构**:

**第一层：Code Graph（静态理解）**
- **不是** tree-sitter 语法树。是经过 AI 增强的**语义图谱**
- 节点：函数 / 类 / 模块 / API 端点 / 数据库表 / 配置项
- 边：调用 / 继承 / 实现 / 依赖 / 数据流 / 影响传播
- 增量构建：文件保存时 < 100ms 局部刷新
- 查询能力：
  - "修改 UserService.login() 会影响哪些 API 端点？" → 3 跳影响分析
  - "这个 Bug 的数据从哪里来？" → 反向数据流追踪
  - "哪些测试覆盖了这个函数？" → 测试-代码映射

**第二层：Intent Graph（动态理解）**
- 用户说"修一下登录"，Intent Graph 能推断出：
  - "登录"指的是 `src/auth/login.ts` 而不是 `src/admin/login.ts`
  - "修一下"意味着最近有相关 Bug report 或失败的测试
  - 上下文应包含：登录函数 + 最近的错误日志 + 相关测试 + API 路由定义
- 多轮对话中维护意图状态机，避免每轮都从零理解

**第三层：Project Memory（持久理解）**
- 跨会话记忆，越用越聪明：
  - "上次你让我用 Zod 做校验而不是手动 if-else，我记住了"
  - "这个项目的 API 响应格式统一用 `{ data, error, meta }`"
  - "团队约定：数据库字段用 snake_case，TypeScript 用 camelCase"
- 记忆分层：个人记忆 / 团队记忆 / 项目记忆
- 记忆可审查、可编辑、可导出

**量化指标**:

| 指标 | Claude Code (基线) | Kanata 目标 |
|------|-------------------|-------------|
| 上下文精准率 (相关文件命中率) | ~60% | ≥ 90% |
| 首轮任务完成率 (无需追问) | ~45% | ≥ 70% |
| 上下文 Token 浪费率 | ~40% | ≤ 15% |
| 跨文件修改一致性 | ~70% | ≥ 95% |

---

### 壁垒二：Multi-Brain Verification — "三个大脑比一个靠谱"

> **核心洞察**: 单一模型的输出不可控。用户最痛的不是"AI 不够聪明"，而是"AI 犯的错我发现不了"。Kanata 的杀手特性是**多模型交叉验证**——用一个模型写代码，用另一个模型审查，用第三个模型验证，成本增加 30%，可靠性提升 300%。

**为什么这是护城河**: Claude Code 绑定 Anthropic 模型，不可能做交叉验证。Cursor 绑定少数模型。只有 Kanata 的多模型架构才能做到真正的 Multi-Brain。

```
用户指令: "给 UserService 增加缓存功能"
                    │
                    ↓
        ┌───────────────────────┐
        │    Brain 1: 生成       │  ← Claude Opus (最强生成)
        │    "写出缓存实现代码"   │
        └───────────┬───────────┘
                    │ 生成的代码
                    ↓
        ┌───────────────────────┐
        │    Brain 2: 审查       │  ← DeepSeek V3 (独立视角)
        │    "这段代码有没有问题" │
        │                       │
        │  发现: 缓存未设过期时间 │
        │  发现: 并发写入无锁保护 │
        └───────────┬───────────┘
                    │ 审查意见
                    ↓
        ┌───────────────────────┐
        │    Brain 1: 修正       │  ← 基于审查意见修改
        │    "修复发现的问题"     │
        └───────────┬───────────┘
                    │ 修正后代码
                    ↓
        ┌───────────────────────┐
        │    Brain 3: 验证       │  ← GPT-4o (第三方验证)
        │    "生成测试验证正确性" │
        └───────────┬───────────┘
                    │ 验证通过 ✓
                    ↓
                用户看到的最终结果
          (附带置信度: 97% verified)
```

**Multi-Brain 模式**:

| 模式 | Brain 数量 | 成本倍率 | 适用场景 | 用户选择 |
|------|-----------|---------|---------|---------|
| **Fast** | 1 | 1x | 简单补全、格式化、解释 | 默认 |
| **Balanced** | 2 | 1.5x | 常规编码、Bug 修复 | 手动选择 |
| **Verified** | 3 | 2x | 关键代码、安全敏感、架构变更 | 手动选择 |
| **Consensus** | 3+ | 2.5x | 生产部署前的最终审查 | 关键场景推荐 |

**关键设计**:
- 用户看到的是**一个统一的 Agent**，不感知背后有几个模型在工作
- 每次输出附带**置信度分数** (0-100%)，基于多模型一致性计算
- 置信度 < 80% 时自动提示用户人工确认
- 成本可控：用户可以在设置中选择默认模式

---

### 壁垒三：Organization Learning Network — "团队越用越聪明"

> **核心洞察**: 个人工具容易被替换，组织级平台难以迁移。当 Kanata 积累了一个团队的编码规范、架构决策、Bug 模式、成员偏好，团队就不会轻易更换。这是 Kanata 的**数据飞轮**。

```
                    ┌──────────────────┐
                    │   数据飞轮模型    │
                    └──────────────────┘

       ┌──────┐  更多使用  ┌──────────┐
       │ 用户 │ ─────────→ │ 交互数据 │
       │ 增长 │            │ 积累     │
       └──┬───┘            └────┬─────┘
          ↑                     │
          │                     ↓
    ┌─────┴──────┐      ┌──────────────┐
    │ 口碑传播    │      │ 模型更精准    │
    │ 难以迁移    │      │ 上下文更精确   │
    └─────┬──────┘      └──────┬───────┘
          ↑                     │
          │                     ↓
       ┌──┴──────┐       ┌─────┴──────┐
       │ 任务完成 │ ←──── │ 输出质量    │
       │ 率提升   │       │ 更高       │
       └─────────┘       └────────────┘
```

**Organization Learning 具体内容**:

1. **编码规范自动提取与执行**
   - 首次使用扫描代码库，自动提取命名规范、代码风格、目录约定
   - 新代码自动遵循，偏离时自动提醒
   - 不需要写 ESLint 规则——AI 直接从代码中学

2. **架构决策库 (ADR Auto-Capture)**
   - 每次 Agent 做出架构决策（选 Redis 还是 Memcached？用 REST 还是 GraphQL？）自动记录
   - 下次类似决策时引用历史：" 上次你们在 OrderService 选了 Redis，这次 PaymentService 也用 Redis 保持一致？"

3. **Bug 模式库**
   - 记录每次修复的 Bug：症状 → 根因 → 修复方案
   - 类似 Bug 再现时秒级定位："这个错误和上次 User #42 遇到的一样，根因是 timezone 转换"

4. **成员能力画像**
   - 自动识别每个成员擅长的领域
   - 任务推荐时考虑："这个 Kubernetes 配置问题推荐给 Alice，她上次处理过类似的"

5. **团队知识图谱**
   - "谁最了解支付模块？" → 基于代码贡献 + Agent 交互历史自动回答
   - "这个功能上次谁做的？" → 自动关联代码变更和 Agent 会话

**迁移成本量化**:

| 使用时长 | 积累的组织知识 | 迁移成本 |
|---------|-------------|---------|
| 1 周 | 基础代码规范 | 低 — 可替代 |
| 1 个月 | 规范 + 架构决策 + 个人偏好 | 中 — 有摩擦 |
| 3 个月 | + Bug 模式 + 团队知识图谱 | 高 — 严重损失 |
| 6 个月 | + 成员画像 + 历史决策全量 | 极高 — 几乎不可能 |

---

## 三、杀手级用户体验：零配置、零学习、零等待

### 3.1 "30 秒体验" 原则

> 用户从安装到第一次成功完成任务，不超过 30 秒。

```bash
# 这就是 Kanata 的全部上手流程
$ npm install -g kanata     # 或 brew install kanata
$ cd my-project
$ kanata

  🏔 Kanata v1.0
  检测到项目: React + TypeScript + Tailwind
  已自动加载项目上下文 (1,247 文件, 89K LOC)

  > 有什么可以帮你的？

$ 帮我修复 #42 号 Bug

  ✓ 从 GitHub 获取 Issue #42: "用户登录后跳转异常"
  ✓ 定位相关文件: src/auth/redirect.ts (Line 47)
  ✓ 分析根因: useEffect 缺少 dependency
  ✓ 生成修复方案

  [Verified 97%] 以下修改将修复此 Bug:
  ... (展示 diff)

  应用修改? [Y/n]
```

**关键设计**:
- **零配置**: 首次运行自动检测项目类型、框架、包管理器，无需任何配置文件
- **零注册**: 支持多种 API Key 直接使用，不需要 Kanata 自己的账号体系（MVP 阶段）
- **智能 API Key 检测**: `ANTHROPIC_API_KEY`, `OPENAI_API_KEY` 等环境变量自动识别
- **渐进式复杂度**: 新手只需要知道 `kanata` 一个命令，高级功能按需发现

### 3.2 "一句话完成" 设计哲学

当前 Claude Code 的问题：用户经常需要多轮对话才能让 Agent 理解意图。Kanata 的目标是**一句话完成率 ≥ 70%**。

| 用户输入 | Claude Code 典型行为 | Kanata 目标行为 |
|---------|---------------------|----------------|
| "修复 CI" | "请提供 CI 错误信息" | 自动读取最近 CI 日志，定位失败原因，直接修复 |
| "加个缓存" | "请说明要给哪个功能加缓存" | 分析最近性能瓶颈 / 频繁查询，推断最可能的缓存目标 |
| "重构这个" | "请说明重构方向" | 分析代码异味，给出 2-3 个重构方案供选择 |
| "像 Stripe 那样" | "请提供更多细节" | 理解为"参考 Stripe 的 API 设计风格/支付流程"，给出具体方案 |

**实现方式**: Intent Graph + Project Memory 协作推断

### 3.3 置信度可视化

每次 Agent 输出都附带置信度，让用户知道"该信任多少"：

```
┌────────────────────────────────────────────────────┐
│  修改 src/auth/login.ts                             │
│                                                    │
│  - 添加 Redis 缓存层                                │
│  - 设置 TTL 为 3600 秒                              │
│  - 添加缓存穿透保护                                  │
│                                                    │
│  置信度: ████████████████████░░ 92%                  │
│                                                    │
│  ┌─ 置信度明细 ──────────────────────────────────┐  │
│  │ 代码正确性:  95%  (Multi-Brain 一致)           │  │
│  │ 架构合理性:  90%  (符合项目现有模式)            │  │
│  │ 测试覆盖:   88%  (自动生成 3 个测试全通过)      │  │
│  │ 安全性:     96%  (无已知漏洞模式)              │  │
│  └───────────────────────────────────────────────┘  │
│                                                    │
│  [应用] [查看 diff] [让我解释] [重新生成]            │
└────────────────────────────────────────────────────┘
```

---

## 四、用户旅程与关键场景

PRD 不能只有功能列表，必须有**具体场景**让团队理解"用户到底怎么用"。

### 场景 1：个人开发者日常

```
张三，全栈工程师，在一个 React + Node.js 项目上工作。

08:30  打开终端，输入 kanata
       → Kanata 自动加载项目上下文，显示: "昨天你在做用户个人资料页，继续？"
       张三: "继续，帮我加上头像上传功能"

08:32  Kanata 输出完整方案:
       → 前端: 文件上传组件 + 图片裁剪 + 预览
       → 后端: 上传 API + S3 存储 + 图片压缩
       → 数据库: users 表添加 avatar_url 字段
       → 置信度: 94% (Multi-Brain Verified)
       张三: "应用"

08:33  Kanata 自动修改 7 个文件，生成 migration 脚本
       → 自动运行测试: 12/12 通过
       → "要我帮你提 PR 吗？"
       张三: "好"

08:34  PR 创建完成，附带 AI 生成的 Summary
       张三去喝咖啡了。整个过程 4 分钟。
```

### 场景 2：团队协作修复生产事故

```
凌晨 3:00  线上告警: 支付接口超时率 > 30%

03:01  值班人 Alice (手机端):
       → 收到 Kanata 推送: "支付接口异常，疑似数据库连接池耗尽"
       → Alice 语音输入: "分析一下什么原因"
       → Kanata 自动拉取近 1 小时日志，分析:
         "17:00 部署的代码引入了一个未关闭的数据库连接，
          connections 表显示连接数从 50 增长到 500。
          根因: src/payment/query.ts Line 89 缺少 finally { conn.release() }"
       → Alice: "能修吗？"
       → Kanata: "修复方案已生成，置信度 98%。需要 Bob 审批"

03:03  Alice @Bob (Kanata 自动发 Slack 通知)
       Bob 打开 Kanata Web 端，看到修复 diff + 置信度
       Bob: "Approve"

03:04  Kanata 自动: 创建 hotfix PR → CI 通过 → 部署到 staging → 监控确认恢复
       → "Staging 环境支付接口恢复正常，确认部署到 production？"

03:05  Bob: "确认"
       → 部署完成，告警解除

事后: Kanata 自动生成事故报告 (RCA)，添加到 Bug 模式库
      下次类似代码自动检测: "这里有未释放连接风险"
```

### 场景 3：新人入职第一天

```
新人小王加入团队，第一天：

小王: kanata
Kanata: "欢迎！我检测到这是你首次使用此项目。
         项目: E-commerce Platform (React + Go + PostgreSQL)
         启动 Onboarding 引导？"
小王: "好"

Kanata: "📁 项目结构概览:
         - frontend/: React 18 + TypeScript，131 个组件
         - backend/:  Go 1.21，42 个 API 端点
         - infra/:    Kubernetes + Terraform

         🏛 关键架构决策:
         - 前后端通过 GraphQL 通信 (2024-03 决策，ADR-007)
         - 使用 Event Sourcing 处理订单状态 (2024-06 决策，ADR-012)
         - 认证使用 JWT + Refresh Token (2023-11 决策，ADR-003)

         👥 模块负责人:
         - 支付模块: Alice (最熟悉，贡献 67% 代码)
         - 前端组件库: Bob (维护者)
         - 基础设施: Carol (DevOps Lead)

         要深入了解哪个模块？"

小王: "我负责前端，帮我了解前端代码"
Kanata: [自动生成前端模块的交互式导览...]
```

---

## 五、商业模式与增长策略

### 5.1 定价模型

| 层级 | 价格 | 目标用户 | 包含内容 |
|------|------|---------|---------|
| **Free** | $0 | 个人开发者试用 | 自带 Key + 基础 CLI + 每日 50 次交互 |
| **Pro** | $29/月 | 专业个人开发者 | 自带 Key + 全功能 CLI + 无限交互 + Project Memory |
| **Team** | $49/人/月 | 小团队 (≤20人) | Pro 全部 + Key 池化 + 团队协作 + Web 端 |
| **Enterprise** | 定制 | 大组织 | Team 全部 + 私有部署 + SSO + 合规 + SLA |

**关键策略**: Free 层不限模型（用户自带 Key），降低体验门槛；付费核心是**组织级功能**（Key 池化、团队记忆、协作）。

### 5.2 增长飞轮

```
                    个人开发者试用 (Free)
                           │
                           ↓
                    体验超出预期 (Context Engine)
                           │
                           ↓
               在团队中推荐 → 团队试用 (Team Trial)
                           │
                           ↓
               团队积累组织知识 → 迁移成本递增
                           │
                           ↓
               转为付费 Team/Enterprise
                           │
                           ↓
               更多数据 → 产品更好 → 更多推荐
```

### 5.3 开源策略

| 组件 | 开源 / 闭源 | 理由 |
|------|-----------|------|
| CLI 客户端 | 开源 (MIT) | 降低信任门槛，社区贡献 |
| Tool & Skill 框架 | 开源 (MIT) | 生态建设，第三方 Skill |
| Agent Core 基础版 | 开源 (AGPL) | 建立社区，AGPL 保护商业 |
| Context Engine | 闭源 | 核心竞争力，不开源 |
| Multi-Brain 编排 | 闭源 | 核心竞争力 |
| Organization Learning | 闭源 | 数据飞轮，核心壁垒 |
| 管理面板 (Web) | 闭源 | 付费功能 |

---

## 六、被忽略的关键设计

### 6.1 错误恢复机制 (Error Recovery)

当前 PRD 完全没有讨论**Agent 犯错了怎么办**。这是用户最大的恐惧。

**三层安全网**:

| 层级 | 机制 | 触发时机 |
|------|------|---------|
| **L1: 预览确认** | 所有文件修改先展示 diff，用户确认后写入 | 每次修改前 |
| **L2: 自动快照** | 每次 Agent 操作前自动 git stash 当前状态 | 自动 |
| **L3: 时间回溯** | `kanata undo` 回滚到任意历史操作点 | 用户触发 |

```bash
$ kanata undo
最近的 Agent 操作:
  [3] 10:15 修改 5 个文件 (添加缓存功能)
  [2] 10:08 修改 2 个文件 (修复登录 Bug)
  [1] 09:55 新建 1 个文件 (添加测试)

回滚到哪一步？[1-3] 或 "cancel": 3
✓ 已回滚到操作 [3] 之前的状态
```

### 6.2 渐进式信任模型 (Progressive Trust)

用户对 Agent 的信任应该是**渐进式**的，不应该上来就给全部权限：

```
信任等级 1 (新用户，默认):
  ├── 可以: 读取文件、搜索代码、解释代码
  ├── 需确认: 修改文件、执行命令
  └── 禁止: 删除文件、Git push、网络请求

信任等级 2 (使用 1 周后，用户可升级):
  ├── 可以: 读取、搜索、修改文件
  ├── 需确认: 删除文件、Git 操作
  └── 禁止: Git push、生产环境操作

信任等级 3 (用户主动开启):
  ├── 可以: 所有本地操作、Git commit
  ├── 需确认: Git push、部署
  └── 禁止: 无 (全信任模式)

信任等级 4 (团队管理员配置):
  ├── 可以: 包含 CI/CD 操作
  ├── 需确认: 生产部署
  └── 自动: 按团队策略执行
```

### 6.3 离线优先与数据主权

**被忽略的硬需求**：很多企业和中国用户有严格的数据合规要求。

| 部署模式 | 说明 | 目标用户 |
|---------|------|---------|
| **Cloud** | SaaS，Kanata 托管 | 个人 / 小团队 |
| **Hybrid** | Agent 本地运行，仅 API 调用走云端 | 数据敏感型企业 |
| **On-Premise** | 完全私有部署，含模型推理 | 金融/政府/军工 |
| **Air-Gapped** | 断网环境，本地模型 (Llama/Qwen) | 特殊合规要求 |

**本地模型支持策略**:
- 集成 Ollama / vLLM 作为本地推理后端
- 针对 Code Agent 场景微调的小模型 (7B-34B) 作为离线备选
- 离线模式下 Context Engine 仍然可用（不依赖云端）

### 6.4 竞品迁移路径

用户不会凭空出现，他们从 Claude Code / Cursor / Copilot 迁移过来。需要**零摩擦迁移**：

```bash
$ kanata migrate --from claude-code
✓ 检测到 Claude Code 配置 (~/.claude/)
✓ 导入 API Key 配置
✓ 导入项目偏好 (CLAUDE.md → .kanata/memory.yaml)
✓ 导入命令别名
✓ 迁移完成！你的所有习惯都保留了。

$ kanata migrate --from cursor
✓ 检测到 Cursor 配置
✓ 导入 .cursorrules → .kanata/rules.yaml
✓ 导入自定义 prompts
✓ 迁移完成！
```

### 6.5 Prompt Engineering 作为一等公民

当前 PRD 把 System Prompt 当作实现细节，但**Prompt 质量决定了 Agent 质量的 80%**。

**Prompt 管理体系**:

```
.kanata/
├── prompts/
│   ├── system.md              # 核心 System Prompt (版本化)
│   ├── personas/
│   │   ├── coder.md           # 编码人格
│   │   ├── reviewer.md        # 审查人格
│   │   └── architect.md       # 架构师人格
│   ├── rules/
│   │   ├── project-rules.md   # 项目级规则 (类似 CLAUDE.md)
│   │   ├── team-rules.md      # 团队级规则
│   │   └── personal-rules.md  # 个人偏好
│   └── templates/
│       ├── code-review.md     # 代码审查模板
│       ├── bug-fix.md         # Bug 修复模板
│       └── feature.md         # 新功能模板
```

- 每个 Prompt 都有 Git 历史，可追踪效果变化
- A/B 测试 Prompt：两个版本同时运行，用完成率和用户满意度选优
- Prompt 市场：社区分享高效 Prompt，一键安装

### 6.6 可观测的 Agent 思考过程

用户最大的焦虑是"AI 在想什么我不知道"。需要**透明思考**：

```
$ kanata --verbose

> 帮我优化这个查询

🧠 思考过程 (实时流式):
  ├── 读取 src/db/queries.ts ... 找到 getUserOrders()
  ├── 分析 SQL: SELECT * FROM orders WHERE user_id = ?
  │   └── 问题: 缺少 LIMIT，全表扫描
  ├── 检查 Code Graph: 此函数被 3 个 API 调用
  │   └── 最高 QPS 的调用方: /api/user/dashboard (120 QPS)
  ├── 查阅 Project Memory: 团队约定使用 pagination
  ├── 生成优化方案:
  │   ├── 方案 A: 添加 LIMIT + OFFSET (简单)
  │   ├── 方案 B: 游标分页 (高性能)
  │   └── 选择方案 B (因为 QPS > 100)
  └── Multi-Brain 验证: Brain2 同意, Brain3 同意 → 97%

📝 最终输出:
  [展示优化后的代码]
```

**默认折叠**（不干扰新手），`--verbose` 或 UI 展开按钮显示。

---

## 七、MVP 中需要嵌入的"种子"

以下能力不需要在 MVP 中完整实现，但**架构上必须预留**，否则后期改造成本极高：

| 种子 | MVP 中做到什么程度 | 为什么必须现在埋 |
|------|------------------|-----------------|
| Context Engine | Code Graph 的索引接口 + 空实现 | 后续所有智能功能依赖此接口 |
| Multi-Brain | LLMClient 支持多实例 + 路由接口 | 单模型 → 多模型是架构级变更 |
| Organization Learning | 本地 `.kanata/memory.yaml` 读写 | Project Memory 的数据格式需要从 Day 1 稳定 |
| 信任模型 | 操作权限枚举 + 确认流程 | 安全模型事后补很危险 |
| 置信度 | 输出中预留 confidence 字段 | 前端展示 + 用户信任建设 |
| Undo 机制 | 操作前自动 git stash | 架构上需要操作日志 |
| Prompt 管理 | System Prompt 从文件加载而非硬编码 | Prompt as Code 的基础 |
| 迁移工具 | 识别 `.claude/` 和 `.cursorrules` 的能力 | 首次运行的用户体验 |

---

## 八、修订后的核心 Slogan 与定位

**原定位** (PRD v1.1):
> "多模型 + 多团队 + 全终端 + 成本可控 + 自我进化"
>
> 问题：这是功能描述，不是价值主张。用户不关心你有多少功能，只关心"对我有什么好处"。

**修订定位**:

> **Kanata — The Code Agent That Knows Your Project**
>
> *越用越懂你的项目，越用越难以替代的 AI 编程伙伴*

三句话说清价值：
1. **最懂你的代码**: Context Engine 让 AI 真正理解你的项目，一句话完成任务
2. **最可靠的输出**: Multi-Brain 多模型交叉验证，每次修改附带置信度
3. **越用越聪明**: Organization Learning 积累团队知识，成为不可替代的团队资产

---

## 九、核心指标修订

原 KPI 太笼统，补充面向**核心特色**的指标：

| 维度 | 指标 | MVP 目标 | 6 个月目标 |
|------|------|---------|-----------|
| **Context 质量** | 一句话任务完成率 | 50% | 70% |
| **Context 质量** | 上下文精准率 | 70% | 90% |
| **可靠性** | Multi-Brain 后 Bug 引入率 | N/A (MVP 单 Brain) | 比单 Brain 降低 60% |
| **可靠性** | 用户 Undo 率 | < 20% | < 8% |
| **粘性** | 30 天留存率 | 40% | 65% |
| **粘性** | 团队 → 付费转化率 | N/A | 15% |
| **飞轮** | Project Memory 条目数/项目 | 50+ | 500+ |
| **飞轮** | Organization Learning 条目数/团队 | N/A | 200+ |
| **体验** | 首次任务完成时间 | < 60s | < 30s |
| **体验** | NPS (净推荐值) | > 30 | > 50 |

---

## 十、总结：Kanata 的竞争公式

```
Kanata 的竞争优势 =
    Context Engine (最懂你的代码)
  × Multi-Brain (最可靠的输出)
  × Organization Learning (越用越聪明)
  × 多模型 + 多终端 + 低成本 (基础能力覆盖)
```

前三项是**壁垒**（竞品难以复制），第四项是**门槛**（必须有但不构成差异）。

Claude Code 有 Anthropic 模型优势但无法多模型验证。
Cursor 有编辑器体验但无组织级学习。
Devin 有自主性但不透明不可控。
Copilot 有分发渠道但智能程度不足。

**Kanata 的独特位置**: 唯一一个同时具备**深度上下文理解** + **多模型可靠性** + **组织级知识积累**的 Code Agent 平台。

---

*补充文档维护者: Kanata Product Team*
*最后更新: 2026-01-31*
